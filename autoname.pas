program autoname;

(*+------------------------------------------------------------------------+
   AutoNAME: A fantasy name generator for use with AutoREALM

   Compile with Free Pascal:
   	fpc -Tdarwin -Mdelphi autoname.pas

   There are two types of rules used in the .rul files read by AutoNAME.
   They are production rules (=>) and replacement rules (==).  Comments
   are started by //, and continue to the end of a line.
   Characters can be escaped with a backslash, and \n will insert a newline.

   To insert another .rul file, use
         #include FILENAME
   on a line by itself, which will insert FILENAME at the point of inclusion.

   Production rules govern generation of strings, are randomly selected
   (using either an equal percentage, or one supplied by the user), and
   follow a context free grammar.  Although all non-terminals are by
   convention upper-case, any series of consecutive alpha characters can
   be used as a non-terminal.  Any non-alpha characters can be used to
   separate a non-terminal.

   The first non-terminal in the file is considered the primary rule,
   and is used to start each generated name.  Any line that is missing
   a left hand side or arrow uses the last valid non-terminal.

   Production rules may have a percentage or weight to the left of the
   arrow.  All rules that are part of a non-terminal that do not have
   a specified probability divide the remaining probability equally among
   themselves. E.g.
       RULE [%25] => One quarter the time
            [%50] => One-half the time
            [.10] => Ten percent of the time
                  => Remaining percent split between this rule
                  => and this one, for 7.5% each.

   The following special symbols are used in production rules:
     ""      Quotes the rule contents.
               E.g. RULE => "His'n hers"

     {}      Can be used to separates two adjacent non-terminals.
               E.g. RULE => {FIRST}{LAST}
             Also may contain "roll" expressions, like 3d6, etc. for
             rolling dice.  Rolls must be of the form
             {<NUMDICE>d<DIEFACES>[Max|Min<INTEGER>][+|-<INTEGER>]}
               E.g. RULE => {3d6}{4d4+2}{5d6Max3}

     []      Contents of brackets are inserted 50% of the time.
             E.g. RULE => This [and] that

     `       Hypenation point for probilistic word breaks (splits towards front of word)
             E.g. RULE => in`fin`ite        
                // Generates either "in", "infin", or "infinite"
                // with equal probability

     <>      Accumulator: used to create a descriptive buffer,
             allowing independently placed but semantically linked
             text to be generated within the rule.  Any text inside
			 the angle brackets is placed in a buffer to be expanded later.
			 All buffers start as empty at the beginning of the primary rule.
             Accumulators may be named, allowing multiple parallel accumulators
			 being active in the rule set.

             <NAME=TEXT>	Set accumulator NAME to TEXT
             <NAME+=TEXT>	Append TEXT to accumulator NAME
			 <=NAME=>       Insert accumulator contents
			 <TEXT>			Append TEXT to default unnamed accumulator
			 <>				Insert contents of default unnamed accumulator

			 An example with multiple named accumulators:

                     TOPRULE => PERSON likes <=PERSONS=> PET because <=PRONOUN=> is a <=GENDER=>
                     PERSON => Johnny<PERSONS=his><PRONOUN=he><GENDER=boy>
                            => Jane<PERSONS=her><PRONOUN=she><GENDER=girl>
                     PET    => dog
                            => cat

             A simpler example with a single, default accumulator:

                     TOPRULE => RULE means <>  // Show word and its meaning
                     RULE => Arg <Anvil>       // Arg means "Anvil"
                          => Blarg <Foe>       // Blarg means "Foe"

			 Rules that fill the accumulator must be encountered prior
			 to the accumulator expansion, otherwise they will be empty.
			 For example, this will not work properly:
			         TOPRULE => <=LIGHTCOLOR=> is COLOR mixed with white.
					 COLOR => black<LIGHTCOLOR=gray>
						   => red<LIGHTCOLOR=pink>
             because rule execution happens sequentially. As TOPRULE is parsed,
			 the expansion of the LIGHTCOLOR accumulator is encountered
			 prior to it being filled from the COLOR rule.


   Replacement rules are applied after all production rules are finished.
   Replacement rules occur in order, replace until no longer applicable,
   do not require any particular strings on either left or right hand
   sides, and are always applied (i.e. not random).
   They are used for correcting problems generated by pasting adjacent
   text that would be very difficult to fix by altering the rules themselves.

   E.g.
         //
         // Replacement rules: fix up any bad English
         //
         The The==The
         s's==s'
         Mummys==Mummies

 +------------------------------------------------------------------------+*)

uses SysUtils;

type PRule = ^Rule;
     Rule = record
       contents:string;
       probability:single;
       next:PRule;
     end;

     PProduction = ^Production;
     Production = record
       name:string;
       rules:PRule;
       next:PProduction;
     end;

     PReplacement = ^Replacement;
     Replacement = record
       left,right:string;
       next:PReplacement;
     end;

	PAccumulator = ^Accumulator;
	Accumulator = record
		name:string;
		contents:string;
		next:PAccumulator;
	end;


const RecursionMax = 50;                // Hope it never gets this deep!
      ReplacementMax = 20;              // Just in case they add bad rules like
                                        // A==AA which will recurse forever.
resourcestring
  res_autonamegen_noprob =  'Probability is missing ]';
  res_autonamegen_brace =   'Unmatched {} braces';
  res_autonamegen_bracket = 'Unmatched [] brackets';
  res_autonamegen_angle =   'Unmatched <> brackets';
  res_autonamegen_quote =   'Unmatched "" quotes';
  res_autonamegen_unknown = 'Probability ends with unknown character';
  res_autonamegen_label_noprod = 'Found => with no prior production label (left hand side)';
  res_autonamegen_99 =      'probability totals less than 100%';    // 1 space is added before
  res_autonamegen_101 =     'probability totals greater than 100%'; //    "     "
  res_autonamegen_notexist= 'does not exist.';                      //    "     "
  res_autonamegen_toomuch = 'contained too many errors; parsing aborted.';//    "

var FirstProduction:PProduction;        // First in the list
    PrimaryProduction:PProduction;      // The first in the file: we generate this top rule
    CurrentProduction:PProduction;      // Rule being added to implicitly
    PrintProbabilities:boolean;         // Set by command line -p
    RecursionDepth:integer;             // Prevent stack overflows
    FirstReplacement:PReplacement;      // First replacement
    LastReplacement:PReplacement;       // Last replacement
    ErrorString:string;                 // String for accumulated errors
	FirstAccumulator:PAccumulator;		// List of accumulator

function RandomRule(prod:PProduction):string; forward;
function ReadRules(name:string):boolean;      forward;

function FindProduction(s:string):PProduction;
var pr:PProduction;
begin
  pr:=FirstProduction;

  while (pr<>nil) do begin
    if (s=pr^.name) then begin
      Result:=pr; exit;
      end;
    pr:=pr^.next;
    end;

  Result:=nil;
end;


procedure ClearAccumulators();
var current,next:PAccumulator;
begin
	current := FirstAccumulator;
	while (current<>nil) do begin
	  next := current^.next;
	  Dispose(current);
	  current := next;
	  end;
	FirstAccumulator := nil;
end;


function FindAccumulator(accum:string):PAccumulator;
var current:PAccumulator;
begin
	current := FirstAccumulator;
	while (current<>nil) do begin
	  if (current^.name=accum) then begin
	    Result:=current;
		exit;
		end;
	  current := current^.next;
	  end;
	Result:= nil;
end;

procedure AddAccumulator(accum:string; newcontent:string);
var find:PAccumulator;
begin
	find := FindAccumulator(accum);
	if (find=nil) then begin
	  New(find);
	  find^.name := accum;
	  find^.contents := '';
	  find^.next := FirstAccumulator;
	  FirstAccumulator := find;
	  end;

	find^.contents := find^.contents + newcontent;
end;

function GetAccumulator(accum:string):string;
var find:PAccumulator;
begin
	find := FindAccumulator(accum);
	if (find=nil) then begin
	  Result := '';
	  end
	else begin
	  Result := find^.contents;
	  end;
end;

procedure EmptyAccumulator(accum:string);
var find:PAccumulator;
begin
	find := FindAccumulator(accum);
	if (find<>nil) then begin
	  find^.contents := '';
	  end;
end;

//-----------------------------------------------------------------------
// Given a string that may contain a die roll, figure out if it does or
// not, and roll it if necessary.
//    <NUMDICE>d<DIEFACES>[Max|Min<INTEGER>][+|-<INTEGER>]
//-----------------------------------------------------------------------
function ComputeRoll(s:string):string;
const MAX_DICE=100;
var num_dice:integer;
    die_faces:integer;
    addition:integer;
    domin,domax:boolean;
    eliminatedies:integer;
    i,err,sum:integer;
    dice:array[0..MAX_DICE] of integer;

   procedure QuickSort(L, R: Integer);
   var
     I, J: Integer;
     P: integer;

     procedure Exchange(var l,r:integer);
     var t:integer;
     begin
       t:=l; l:=r; r:=t;
     end;

   begin
     repeat
       I := L;
       J := R;
       P := dice[(L + R) shr 1];
       repeat
         while dice[i]<P do Inc(I);
         while dice[j]>P do Dec(J);
         if I <= J then
         begin
           Exchange(dice[I],dice[J]);
           Inc(I);
           Dec(J);
         end;
       until I > J;
       if L < J then QuickSort(L, J);
       L := I;
     until I >= R;
   end;

   procedure safeVal(s:string; var n,e:integer);
   var e2:integer;
   begin
     Val(s,n,e);
     if (e<>0) then begin
       Val(copy(s,1,e-1),n,e2);
       end;
   end;

begin
  Result:=s;
  if (length(s)=0) then exit;

  // Do we have a non-zero number followed by a 'd'?
  safeVal(s,num_dice,err);
  if (err=0) or (s[err]<>'d') then exit;

  safeVal(copy(s,1,err-1),num_dice,err);
  if (num_dice>MAX_DICE) then exit;

  delete(s,1,err);          // Remove "<NUMDICE>d"

  addition:=0;
  domin:=false;
  domax:=false;
  eliminatedies:=0;

  // What is the number following the d?
  // If it's a percentile (3d00) then check specially, cause that'll come
  // out as zero.
  if (copy(s,1,2)='00') then begin
    die_faces := 100;
    delete(s,1,2);
    end
  else begin
    safeVal(s,die_faces,err);
    if (die_faces=0) then exit;
    if (err<>0) then delete(s,1,err-1);     // Delete number die faces.
    end;

  // Look for a min or max or +/- past the number of die-faces
  if (length(s)<>0) then begin
    if (Uppercase(copy(s,1,3))='MAX') then begin
      delete(s,1,3);
      domax:=true;
      end;
    if (Uppercase(copy(s,1,3))='MIN') then begin
      delete(s,1,3);
      domin:=true;
      end;
    if domin or domax then begin
      safeVal(s,eliminatedies,err);
      if (eliminatedies<>0) then eliminatedies:=num_dice-eliminatedies;
      if (err=0) then s:='' else delete(s,1,err-1);
      end;

    if (copy(s,1,1)='+') or (copy(s,1,1)='-') then begin
      safeVal(s,addition,err);
      if (err<>0) then delete(s,1,err-1);
      end;
    end;

  for i:=0 to num_dice-1 do dice[i] := Random(die_faces)+1;

  sum:=0;

  if domax then begin
    QuickSort(0,num_dice-1);
    for i:=0 to num_dice-eliminatedies-1 do sum:=sum+dice[i+eliminatedies];
    end
  else if domin then begin
    QuickSort(0,num_dice-1);
    for i:=0 to num_dice-eliminatedies-1 do sum:=sum+dice[i];
    end
  else begin
    for i:=0 to num_dice-1 do sum:=sum+dice[i];
    end;

  Result:=IntToStr(sum+addition);
end;

function AddProduction(s:string):PProduction;
var pr:PProduction;
begin
  pr:=FindProduction(s);

  if (pr<>nil) then
    Result:=pr
  else begin
    New(Result);
    Result^.next:=FirstProduction;
    Result^.name:=s;
    Result^.rules:=nil;
    FirstProduction := Result;
    if (PrimaryProduction=nil) then PrimaryProduction := Result;
    end;
end;


function AddReplacement(left,right:string):PReplacement;
begin
  New(Result);
  Result^.left:=left;
  Result^.right:=right;
  Result^.next := nil;
  if (LastReplacement=nil) then
    FirstReplacement := Result
  else
    LastReplacement^.next := Result;

  LastReplacement:=Result;
end;

function DoReplacements(s:string):string;
var count:integer;
    rep:PReplacement;
    p:integer;
begin
  rep:=FirstReplacement;
  while (rep<>nil) do begin
    count:=0;
    repeat
      p:=pos(rep^.left,s);
      if (p<>0) then begin
        delete(s,p,length(rep^.left));
        insert(rep^.right,s,p);
        inc(count);
        end;
    until (p=0) or (count>ReplacementMax);

    rep:=rep^.next;
    end;

  Result:=s;
end;

function AddRule(prod:PProduction; s:string; prob:single):PRule;
begin
  New(Result);
  Result^.contents:=s;
  Result^.probability:=prob;
  Result^.next := prod^.rules;
  prod^.rules := Result;
end;


function GetToken(var s:string):string;
var len:integer;
begin
  len:=0;
  while (len<=length(s)) and (s[len+1] in ['A'..'Z','a'..'z','`']) do inc(len);

  // If not an alphanumeric word, then get the next char solo
  if (len=0) then len:=1;

  Result:=copy(s,1,len);
  delete(s,1,len);
end;


function GetUntil(var s:string; ch:char; var found:boolean):string;
var len:integer;
begin
  found:=false;
  len:=0;
  while (len<=length(s)) and (s[len+1]<>ch) do inc(len);

  Result:=copy(s,1,len);
  if (len<=length(s)) and (s[len+1]=ch) then begin
    inc(len);
    found:=true;
    end;
  delete(s,1,len);
end;

function GetUntilCounted(var s:string; starter,stopper:char; var found:boolean):string;
var len:integer;
    pair:integer;
begin
  found:=false;
  len:=1;
  pair:=1;
  while (len<=length(s)) and (pair>0) do begin
    if (s[len]=starter) then inc(pair);
    if (s[len]=stopper) then dec(pair);
    inc(len);
    end;

  if (pair=0) then begin
    Result:=copy(s,1,len-2);
    delete(s,1,len-1);
    found:=true;
    end;
end;

function GetName(s:string):string;
var pr:PProduction;
begin
  pr:=FindProduction(s);
  if (pr=nil) then
    Result:=s
  else
    Result:=RandomRule(pr);
end;

function GetRule(contents:string; ParseOnly:boolean):string;
var tok:string;
    found:boolean;
	accum_name:string;
	append:boolean;
	expansion:boolean;
begin
  Result:='';
  if (contents='') then exit;

  if (RecursionDepth=RecursionMax) then exit;

  inc(RecursionDepth);

  repeat
    tok:=GetToken(contents);
    if (length(tok)=1) then begin
      case tok[1] of
	    '\': begin
		       tok := copy(contents,1,1);
			   delete(contents,1,1);
			   if (tok='n') then
		         Result := Result + #13#10
			   else
				 Result := Result + tok;
		     end;
        '{': begin
               tok:=GetUntil(contents,'}',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_brace;
                 exit;
                 end;
               if not ParseOnly then begin
                 tok:=ComputeRoll(tok);                   // Roll if necessary
                 Result:=Result+GetName(tok);             // Get {NAME}
                 end;
             end;
        '[': begin
               tok:=GetUntilCounted(contents,'[',']',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_bracket;
                 exit;
                 end;
               // 50% chance of doing the contents of the brackets
               if (not ParseOnly) and (Random >= 0.5) then begin
                 Result:=Result+GetRule(tok,ParseOnly); // Parse as a new rule
                 end;
             end;
        '<': begin
               tok:=GetUntil(contents,'>',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_angle;
                 exit;
                 end;
               if not ParseOnly then begin
				 append := false;
				 expansion := false;

				 // If first character of accum name is =, then this is an expansion
			     if (copy(tok,1,1)='=') then begin
				    delete(tok,1,1);
					expansion := true;
				    end;

				 // See if we have a named accumulator or the default one
				 if (pos('=',tok)<>0) then begin
					accum_name := GetUntil(tok, '=', found);
					// Last character of the accum name is a plus makes this an append
					if (copy(accum_name,length(accum_name),1)='+') then begin
					  delete(accum_name,length(accum_name),1);
					  append := true;
					  end;
					end
				 else begin
				   // No name is default accumulator: always append, and expand if no name provided
				   accum_name := '';
				   append := true;
				   expansion := (tok='');
				   end;

                 if expansion then begin
                    Result:=Result+GetAccumulator(accum_name);
                    end
				  else begin
					if not append then EmptyAccumulator(accum_name);
					AddAccumulator(accum_name, tok);
                    end;
                 end;

             end;
        '"': begin
               tok:=GetUntil(contents,'"',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_quote;
                 exit;
                 end;
               Result:=Result+tok;      // Use the token literaly
             end;
        else // Not a recognized one-character token
          if not ParseOnly then begin
            Result:=Result+GetName(tok);
            end;
        end;
      end
    else begin
      //
      // Any tokens longer than one character
      //
      if not ParseOnly then begin
        Result:=Result+GetName(tok);
        end;
      end;

  until (length(contents)=0);

  dec(RecursionDepth);

  if ParseOnly then Result:='';             // Don't care about
end;

function CountChars(s:string; c:char):integer;
var i:integer;
    n:integer;
begin
    n:=0;
    for i:=1 to length(s) do begin
        if s[i]=c then inc(n);
        end;
    Result := n;
end;


function ParseBacktick(s:string):string;
var tok:string;
    found:boolean;
    r:string;
    prob:single;
    rand:single;
    threshold:single;
    ticks:integer;
begin
    ticks:=CountChars(s,'`');
    if (ticks=0) then begin
        Result := s;
        exit;
    end;

    prob := 1/(ticks+1);
    rand := Random;
    threshold := prob;

    r := '';
    repeat
        tok := GetUntil(s, '`', found);
        r := r+tok;
        if (found) then begin
            if (rand <= threshold) then found:=false;
            threshold := threshold+prob;
        end;
    until (not found);
    Result := r;
 end;

function RandomRule(prod:PProduction):string;
var p:single;
    rul:PRule;
begin
  p:=Random;
  rul:=prod^.rules;

  while (rul<>nil) do begin
    p:= p - rul^.probability;
    if (p<=0.0) then begin
      Result:=ParseBacktick(GetRule(rul^.contents, false));
      exit;
      end;

    rul:=rul^.next;
    end;

  // If we managed to fall through this loop because of some floating
  // point round-off, just use the first rule.
  Result:=ParseBacktick(GetRule(prod^.rules^.contents, false));
end;


function GenerateRule:string;
begin
  // Start with empty accumulators
  ClearAccumulators();

  if PrimaryProduction=nil then
    Result:=''
  else
    Result:=DoReplacements(RandomRule(PrimaryProduction));
end;


function RuleParse(filename:string; linenumber:integer; s:string):boolean;
const IncludeStr='#include';
var rp:integer;
    left,right:string;
    probability:single;

  procedure Error(s:string);
  begin
    ErrorString:=ErrorString+filename+'('+IntToStr(linenumber)+') : '+s+#13#10;
  end;

  procedure RemoveComments(var s:string);
  var cp:integer;
  begin
     cp:=pos('//',s);
     if (cp<>0) then delete(s,cp,length(s));
  end;

  function RemoveProbability(var s:string):single;
  var lp,prob,err:integer;
      prs:string;
  begin
    Result:=0.0;

    lp:=pos('[',left);
    if (lp<>0) then begin
      prs:=copy(s,lp+1,length(s));
      val(prs,prob,err);                    // Get the first err char.

      if (prob<>0) and (err=0) then begin     // Require some type of terminator
        Error(res_autonamegen_noprob); exit;
        end;

      if (prs[err]=']') then begin
        prs:=copy(prs,1,err-1);
        val(prs,Result,err);
        end
      else if (prs[err]='%') then begin
        prs:=copy(prs,1,err-1);
        val(prs,Result,err);
        Result:=Result*0.01;                // Percentage is 1/100th.
        end
      else begin
        Error(res_autonamegen_unknown); exit;
        end;

      s:=Trim(copy(s,1,lp-1));              // Remove the probability
      end;
  end;

  function FixReplacementString(s:string):string;
  begin
    s:=Trim(s);   // Remove spaces
    if (copy(s,1,1)='"') and (copy(s,length(s),1)='"') then begin
      s:=copy(s,2,length(s)-2);
    end;
    Result:=s;
  end;

begin
  Result:=false;
  RemoveComments(s);
  s:=Trim(s);

  // Deal with blank lines (and only-comment lines) first
  if (s='') then begin          // Blank lines are NOPs
    Result:=true; exit;
    end;

  // Deal with included files
  if (copy(s,1,length(IncludeStr))=IncludeStr) then begin
    s:=Trim(copy(s,length(IncludeStr)+1,length(s)));
    Result:=ReadRules(s);
    exit;
    end;

  // Is this a replacement operator?
  rp:=pos('==',s);
  if (rp<>0) then begin
    left:=FixReplacementString(copy(s,1,rp-1));
    right:=FixReplacementString(copy(s,rp+2,length(s)));
    AddReplacement(left,right);
    Result:=true; 
    exit;
    end;

  //
  // Split the line into a LHS and RHS
  //
  rp:=pos('=>',s);              // Find the production rule operator
  if (rp=0) then begin
    left:='';               // With no => operator, make the whole thing
    right:=s;               // the right hand side
    end
  else begin
    left := Trim(copy(s,1,rp-1));
    right:= Trim(copy(s,rp+2,length(s)));
    end;

  // Remove probability if present
  probability := RemoveProbability(left);

  if (left<>'') then CurrentProduction:=AddProduction(left);

  // Must have a production label (implicit or explicit)
  if (CurrentProduction=nil) then begin       // No rule name present
    Error(res_autonamegen_label_noprod); exit;
    end;

  // If the right hand side is empty, don't add a rule for it.
  if (right='') then begin
    Result:=true; exit;
    end;

  // Make sure the rule doesn't contain syntax errors
  if (GetRule(right,true)<>'') then begin
    Error(GetRule(right,true)); exit;
    end;

  AddRule(CurrentProduction, right, probability);

  Result:=true;
end;


function ProbabilityStr(f:single):string;
begin
  Str((f*100.0):7:4,Result);
  Result:=TrimLeft(Result);
  while (Result[length(Result)]='0') do delete(Result,length(Result),1);

  if (Result[length(Result)]='.') then delete(Result,length(Result),1);
end;


function NormalizeProbabilities:boolean;
var prod:PProduction;

  function NormalizeProduction(prod:PProduction):boolean;
  var rul:PRule;
      non_assigned:integer;
      totalprob:single;
      setprob:single;
  begin
    Result:=false;
    // take a first pass to count rules that have no assigned probability
    non_assigned:=0;
    totalprob:=0.0;

    rul:=prod^.rules;
    while (rul<>nil) do begin
      if (rul^.probability=0.0) then
        inc(non_assigned)
      else
        totalprob := totalprob + rul^.probability;

      rul:=rul^.next;
      end;

    if (totalprob>1.0) then begin
      ErrorString:=ErrorString+prod^.name+' '+res_autonamegen_101+#13#10;
      exit;
      end;

    if (non_assigned=0) and (totalprob<1.0) then begin
      ErrorString:=ErrorString+prod^.name+' '+res_autonamegen_99+#13#10;
      exit;
      end;

    if (non_assigned=0) then begin
      Result := true;
      exit;
      end;

    // Divy up the probability equally among those left.
    setprob := (1.0-totalprob)/non_assigned;
    rul:=prod^.rules;
    while (rul<>nil) do begin
      if (rul^.probability=0.0) then rul^.probability:=setprob;

      if PrintProbabilities then begin
        if (prod=PrimaryProduction) then ErrorString:=ErrorString+'*';

        ErrorString:=ErrorString+prod^.name+'['+ProbabilityStr(rul^.probability)+'%]=>'+rul^.contents+#13#10;
        end;

      rul:=rul^.next;
      end;

    Result:=true;
  end;

begin
  Result:=false;
  prod:=FirstProduction;
  while (prod<>nil) do begin
    if not NormalizeProduction(prod) then exit;
    prod:=prod^.next;
    end;
  Result:=true;
end;

function ReadRules(name:string):boolean;
var f:text;
    s:string;
    errorcount:integer;
    linenumber:integer;
begin
  if (pos('.',name)=0) then name:=name+'.rul';

  AssignFile(f,name);
  {$I-}
  Reset(f);
  {$I+}
  if (IOResult<>0) then begin
    ErrorString:=ErrorString+name+' '+res_autonamegen_notexist+#13#10;
    Result:=false;
    exit;
    end;

  RecursionDepth := 0;
  errorcount:=0;
  linenumber:=0;

  while (not EOF(f)) and (errorcount<50) do begin
    readln(f,s);
    inc(linenumber);
    if not RuleParse(name,linenumber,s) then inc(errorcount);
    end;

  if (not EOF(f)) then begin
    ErrorString:=ErrorString+name+' '+res_autonamegen_toomuch+#13#10;
    end;

  CloseFile(f);

  Result := (errorcount=0);
end;


procedure ParseParameters;
var n:integer;
    switch:char;
    i:integer;
    count:integer;
begin
  n:=1;
  while (n<=ParamCount) and
        ((ParamStr(n)[1]='-') or (ParamStr(n)[1]='/')) do
  begin
    if (length(ParamStr(n))>1) then
      switch := ParamStr(n)[2]
    else
      switch:=#0;

    case Upcase(switch) of
      'P': begin
             PrintProbabilities:=true;
             writeln('// Rules marked with * are from the primary rule.');
           end;
      else begin
        writeln(ParamStr(n),' is an unrecognized switch.'); halt(1);
        end;
      end;

    inc(n);
  end;

  if ReadRules(ParamStr(n)) and NormalizeProbabilities then begin
    count:=StrToIntDef(ParamStr(n+1),20);

    if not PrintProbabilities then begin
      for i:=1 to count do writeln(GenerateRule);
      end
    else begin
      // Print out rule probabilities
      writeln(ErrorString);
      end;
    end else begin
      writeln('Error: ', ErrorString);
    end;
end;


begin
  if (ParamCount=0) then begin
    writeln('AutoNAME -- A fantasy name generator for use with AutoREALM');
    writeln('Copyright (c) 1999,2013 Andrew J. Gryc'#13#10);
    writeln('Syntax: AutoNAME [-p] Rulefile[.rul] [Count]');
    writeln('        Generates <Count> names using the given Rulefile.');
    writeln('        Count defaults to 20.'#13#10);
    writeln('Options: -p   Outputs probabilities of rules');
    halt(0);
    end;

  Randomize;
  ErrorString:='';
  PrintProbabilities:=false;
  RecursionDepth := 0;
  FirstProduction:=nil;
  CurrentProduction:=nil;
  FirstReplacement:=nil;
  LastReplacement:=nil;
  FirstAccumulator:=nil;

  ParseParameters;
end.
